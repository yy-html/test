<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
  <title>{{title}}</title>
  <!-- <link rel="stylesheet" href="./node_modules/xterm/dist/xterm.css" /> -->
  <style>

    body * {
      outline: 1px #000 solid;
    }
    .box {
      border: 1px #000 solid;
      height: 100px;
      padding: 2px;
    }
    .box1 {

    }
  </style>
</head>

<body>
  <div class="box" id="box" title="box">
    <div class="box1" id="box1">

    </div>
  </div>

  <script>const log = console.log;const dir = console.dir;const box = document.querySelector('.box')


  
  </script>

  <script>throw void 0

    // 交集观察者
    const io = new IntersectionObserver((entries) => {}, {})
    io.observe(document.getElementById('example'))
    io.unobserve(element)
    io.disconnect()
    // DOM观察者
    const config = { attributes: true, childList: true, subtree: true }
    const observer = new MutationObserver((mutationsList) => {})
    observer.observe(targetNode, config)
    observer.disconnect()

     
    // 技巧
    const a = o.arr || (o.arr = [])
 
    // 圆
    var dt=1;  //弧度0.5,大概30°
    function run(){
        var r=100;
        var Py=Math.sin(dt)*r;
        var Px=Math.cos(dt)*r;
        box.style.left = Px + 'px'
        box.style.top = Py + 'px'
        dt+=0.03
    }
    window.setInterval(run, 10)

    // 浏览器缓存：
    // http缓存：
    // 对于http缓存可以分为3个步骤：
    // 1. 发起请求 2. 后端处理 3. 浏览器响应
    // 当第一次对起源发起请求，服务端会将资源和响应头缓存字段一块返回给客户端，浏览器将资源和响应头缓存在本地；
    // 再次发起请求时，浏览器会判断强缓存字段（Expires：过期时间 / Cache-Control：max-age 过期间隔/秒）是否过期，没有过期的话直接读取本地缓存；
    // 如果强缓存过期，会将协商缓存字段请求头发送给服务器，协商缓存有两个规则：
    // 1. Last-Modified/If-Modifiled-Since：资源最后修改时间
    // 2. ETag/If-None-Match：资源改动唯一标示
    // 服务端在接收到请求后，会判断客户端缓存资源与服务器资源是否一致，如果一致，只返回Header，并返回状态码304，浏览器接收响应后读取本地缓存
    // 如果不一致，返回最新资源和状态码200
    // 缓存位置：
    // 1. Service Worker：运行在浏览器背后的独立线程
    // 2. Memory Cache 内存缓存：（主要包括样式/脚本/图片；会话级 随进程的释放而释放）需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。
    // 3. Disk Cache 硬盘缓存：强缓存（需要根据响应头强缓存字段判断）
    // 4. Push Cache：是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

    // React-事务机制
    // DOM操作
    // => react触发diaptchEvent
    // => 开启事务（事务开启前会将isBatchingUpdates设置为true）
    // => transaction.perform(callback, null, a, b, c, d, e)
    // => 调用两个wrapper对象的initialize初始化方法，
    // => 调用事务回调也就是DOM事件
    // => 回调里调用setState（判断isBatchingUpdates为true 将state放入更新队列，callback放入队列，组件实例放入dityComponents）
    // => 调用两个wrapper对象的close方法（1.更新state 调用生命周期 调用callback 2.reset isBatchingUpdates为false）
    // => 完成本次事务的更新


    // react初始化渲染机制：笔记

    // redux: 
    // {
    //   getState,
    //   dispatch,
    //   subscrib,
    //   replaceReducer,
    // }

    // react-redux
    // Provider：通过props接收store，来getChildContext创建一个context对象，供connect消费
    // connect：connect(mapStateToProps, mapDispatchToProps, mergeProps, optipons)
    //   mapStateToProps(store.getState(), this.props)
    //   mapDispatchToProps(store.dispatch, this.props)
    //   mergeProps: (stateProps, dispatchProps, ownProps) => { return }
    //   optipons: { pure: true }
    // 1.通过上下文拿到store的数据
    // 2.在didMount订阅store的变化监听本组件setState 
    // 3.将3个props形成的mergeProps传递给渲染组件，默认Object.assign({}, ownProps, stateProps, dispatchProps)
    // 4.做优化，默认对比前后store的数据（在changeState里）和ownProps（在willReceiveProps里）
    //   var selector = {
    //     run: function runComponentSelector(props) {
    //       try {
    //         var nextProps = sourceSelector(store.getState(), props);
    //         if (nextProps !== selector.props || selector.error) {
    //           selector.shouldComponentUpdate = true;
    //           selector.props = nextProps;
    //           selector.error = null;
    //         }
    //       } catch (error) {
    //         selector.shouldComponentUpdate = true;
    //         selector.error = error;
    //       }
    //     }
    //   };
    //   selector.run(this.props || nextProps)

    // // react-router：
    // // BrowserRouter：
    // function createBrowserHistory() {
    //   return {
    //     listen(listener) {
    //       transitionManager.appendListener(listener)
    //       if (first) {  // 第一次调用，添加浏览器前进后退事件
    //         window.addEventListener('popstate | hashchange', function handleChange() {
    //           transitionManager.notifyListeners(history.location, history.action)  // 每当浏览器前进返回调用监听函数
    //         })
    //       }
    //     },
    //     push(path) {
    //       window.history.pushState()
    //       transitionManager.notifyListeners(history.location, history.action)
    //     }
    //   }
    // }

    // class Router extends React.Component {  // Router负责提供Provider 调用监听,监听本组件setState来更新location
    //   constructor(props) {
    //     super(props)
    //     this.state = {
    //       location: props.history.location
    //     }
    //     this.unlisten = props.history.listen((location) => {
	  //       if (this._isMounted) {
	  //         this.setState({
	  //           location: location
	  //         });
	  //       } else {
	  //         this._pendingLocation = location;
	  //       }
	  //     })
    //   }
    //   render() {
    //     <Context.Provider
    //       value={{
    //         location: this.state.location,
    //         history: this.props.history,
    //         math: Router.computeRootMatch(this.state.location.pathname),
    //       }}
    //     >{this.props.children}</Context.Provider>
    //   }
    // }

    // export class BrowserRouter extends React.Component {  // BrowserRouter负责提供history对象给Router
    //   constructor(props) {
    //     super(props)
    //     this.history = createBrowserHistory(this.props)
    //   }
    //   render() {
    //     return (
    //       <Router history={this.history}>
    //         {this.props.children}
    //       </Router>
    //     )
    //   }
    // }
    // // Route：
    // class Route extends React.Component {
    //   render() {
    //     return (
    //       <Context.Consumer>
    //         {(context) => {
    //           const { children, component: Component, render } = this.props
    //           const props = Object.assign(  // 做一个merge操作：有自己的属性就用自己的 没有的话就用Router提供的
    //             {},
    //             context,
    //             {
    //               location: this.props.location || context.location,
    //               match: 
    //                 this.props.computedMatch
    //                   ? this.props.computedMatch 
    //                   : path 
    //                     ? matchPath(location.pathname, this.props) 
    //                     : context.math } // 有Switch包裹就用props.
    //           )
    //           return (
    //             children // children > match(path) > component > render
    //               ? typeof children === 'function' 
    //                 ? children(props) 
    //                 : children 
    //               : match // 判断path是否匹配 不匹配的话match为null
    //                 ? Component 
    //                   ? <Component {...props} /> 
    //                   : render 
    //                     ? render(props) 
    //                     : null 
    //                 : null
    //           )
    //         }}
    //       </Context.Consumer>
    //     )
    //   }
    // }
    // // Switch：
    // class Switch extends React.Component {
    //   render() {
    //     return (
    //       <Context.Consumer> 
    //         {(context) => {
    //           const { children } = this.props
    //           const child = children.find((child) => (
    //             child.props.path ?
    //               matchPath(location.pathname, child.props) :
    //               null
    //           ))
    //           return (
    //             React.cloneElement(child, {
    //               location: location,
    //               computedMatch: match
    //             })
    //           )
    //         }}
    //       </Context.Consumer>
    //     )
    //   }
    // }
    // // Redirect：
    // class Redirect extends React.Component {
    //   render() {
    //     return (
    //       <Context.Consumer>
    //         {({ history }) => {
    //           history.push(this.props.to)
    //           return null
    //         }}
    //       </Context.Consumer>
    //     )
    //   }
    // }
    // // Link：
    // class Link extends React.Component {
    //   render() {
    //     return (
    //       <Context.Consumer>
    //         {({ location, history }) => {
    //           return (
    //             <a 
    //               onClick={(event) => {
    //                 event.preventDefault()
    //                 history.push(this.props.to)
    //               }}
    //               href={history.createHref(location)} // 支持右键 (在新标签页中打开)
    //             />
    //           )
    //         }}
    //       </Context.Consumer>
    //     )
    //   }
    // }
    // // withRouter：
    // function withRouter(Component) {
    //   return (props) => (
    //     <Context.Consumer>
    //       {(context) => (
    //         <Component {...context} {...props} />
    //       ) || <Component />}
    //     </Context.Consumer>
    //   )
    // }
    


 
    // react合成事件系统：
    // React 合成事件注册 && 分发 过程
		// mounted && updated
		// 	=>	_updateDOMProperties(处理props):
		// 				对DOM元素设置唯一_rootNodeID
		// 	=>	enqueuePutListener(事件注册;事件存储): 
		// 				在document上注册事件(litsenTo(事件类型, doc)) 处理事件冒泡 && 捕获 同一类型只注册一次 拥有统一回调dispatchEvent;
		// 				将事件压入事件队列(EventPluginHub.putListener()) listenerBank中: { 'click': { `${vNode._rootNodeID}`: callback } }
		// 	=>	ReactEventListener.dispatchEvent(事件执行):
		// 				根据原生事件对象找到事件触发的DOM元素(event.target._rootNodeID: 也就能拿到对应的事件回调) 及该对象对应的Component对象(handleTopLevelImpl)
		// 				生成合成事件对象(ReactEventEmitterMixin)并批量执行回调函数(默认冒泡依次执行target到其父元素的同类事件)
		// 				进行批量更新(runEventQueueInBatch)
		// event._dispatchListeners: 判断父组件有没有同类型事件 将有eventType属性的ReactElement放入 event._dispatchInstances 将对应的回调依次放入event._dispatchListeners

		// react阻止冒泡: event.nativeEvent 获取原生事件对象
		// 1. 阻止合成事件间的冒泡：e.stopPropagation()
		// 2. 阻止合成事件冒泡到原生document事件：e.nativeEvent.stopstopImmediatePropagation()
    // 3. 组织合成事件冒泡到除document以外的其他原生事件：在该原生事件上通过e.target来排除目标元素return
    

    // 新版createContext：
    // 实际上，无论在刚才的demo和 老版Context Legacy Context都无法实现这个功能，这也是老版的context为人诟病的其中一点，那新版Context有什么黑魔法可以实现这个呢？
    // 答案是context变化会引发又一次check
    // 下面稍有些晦涩，涉及到一些Fiber的运作机制：
    // 得益于Fiber的链表机制，一个Provider的所有的consumer里面的children都会注册到事件池里面，并提供一个propagateContextChange方法。
    // Provider变化触发updateContextProvider函数，从而每个consumer的child的Fiber节点会执行propagateContextChange方法（如果位运算通过的话，可以看第二个问题），
    // 在 propagateContextChange 中，以当前 fiber 节点为根的子树中寻找相匹配 Consumer 节点，给与更新标记，当render过程执行到此节点会执行更新。
    // 因此，虽然 shouldComponentUpdate 造成了 Consumer的父组件无法被标记更新，但 Provider 的 propagateContextChange 能使 Consumer 组件重新被标记，从而能够被 render。

    // 同一个createContext生成的Provider对应的Consumer会将 本Consumer组件（或者组件children）给予更新标记，注册到事件池里进行监听
    // 当Proiver组件发生更新并对比（Object.is）value有变更 会在render过程进行对标记节点的更新



// 业务组件当中可以内嵌Route标签做tag切换
// export default class First extends Component{
//     render(){
//         console.log(this)
//         const {match} = this.props
//         return(
//             <div>
//                 <p>First</p>
//                 <NavLink    style={{color: '#000'}}
//                             to={`${match.url}/0`}
//                             activeClassName='active2'
//                             activeStyle={{color: 'pink'}}>
//                     <button>First-params：1</button>
//                 </NavLink>
//                 <NavLink    style={{color: '#000'}}
//                             to={`${match.url}/1`}
//                             activeClassName='active2'
//                             activeStyle={{color: 'pink'}}>
//                             {/*isActive={ () => true}
//                             exact(bool)：为true时，只有当导致和完全匹配class和style才会应用
//                             strict(bool)：为true时，在确定为位置是否与当前URL匹配时，将考虑位置pathname后的斜线*/}
//                     <button>First-params：2</button>
//                 </NavLink>
                
//                 {/* children使用方式与render一致，只不过无论路由是否匹配都会被渲染 但是跟render一样 只有path匹配才有回调的 match 对象 不匹配为null */}
//                 <Route  path={`${match.path}/:id?`}   //设置params非必传：? 枚举params(0|1)
//                         render={ ({match}) => (
//                             <Fragment>
//                                 {match.params.id ? (
//                                     //<FirstList /> 写成这种形式需要传递{...props} 或 组件内使用withRouter
//                                     <Route path={`${match.path}`} component={FirstList} />
//                                 ) : (
//                                     <div>Select</div>
//                                 )}
//                             </Fragment>
//                         )} />
//             </div>
//         )
//     }
// }

    // <EmailInput
    //   defaultEmail={this.props.user.email}
    //   key={this.props.user.id}
    // />
    // 在我们的例子中，我们可以使用用户ID在新用户被选中时重新创建"EmailInput"：
    // 每当ID改变时，EmailInput将被重新创建，它的状态将被重置为最新的defaultEmail值(示例)。
    // 使用这种方法，您不需要向每个输入项添加key。
    // 把key放在整个表单上可能更有意义。每次改变时，表单中的所有组件都将用一个新初始化的状态重新创建。


      // const arr = [7, 5, 3, 6, 4, 8, 1, 2]

      // 冒泡排序：比较相邻两位，满足条件则将其向右移动一位（每一轮排序一位元素）；先写内循环
      // function fn(arr) {
      //   for (let j = 0, length = arr.length; j < length - 1; j ++) {  // 共比较length - 1轮，排到最后一位不用比较
      //     for (let i = 0; i < length - j - 1; i ++) {  // 每一轮排序一位元素，将其放在最右侧
      //       if (arr[i] > arr[i + 1]) {
      //         let temp
      //         temp = arr[i]
      //         arr[i] = arr[i + 1]
      //         arr[i + 1] = temp
      //       }
      //     }
      //   }
      // }

      // 选择排序：依次拿每一位和后边所有元素进行比较，将最小的放在最左边
      // function fn(arr) {
      //   for (let i = 0, length = arr.length; i < length - 1; i ++) {  // 共比较length - 1轮，排到最后一位不用比较
      //     for (let j = i + 1; j < length; j ++) { // 每一轮排序一位元素，将其放在最右侧
      //       if (arr[i] > arr[j]) {
      //         let temp
      //         temp = arr[i]
      //         arr[i] = arr[j]
      //         arr[j] = temp
      //       }
      //     }
      //   }
      // }

      // 快速排序：一个返回一轮排序的递归函数：找到数组中间值 小于放左边 大于放右边，返回这个新数组
      // 思想：将原问题拆分为若干个原理相同的子问题，递归拿到字问题的解，组合为原问题的解
      // function fn(arr){
      //   if (arr.length <= 1) {
      //     return arr
      //   }

      //   const pivotIndex = Math.floor(arr.length / 2)
      //   const [pivot] = arr.splice(pivotIndex, 1)
      //   const left = []
      //   const right = []

      //   for (let i = 0, item; item = arr[i ++];) {
      //     if (item < pivot) {
      //       left.push(item)
      //     } else {
      //       right.push(item)
      //     }
      //   }

      //   // return fn(left).concat([pivot], fn(right))
      //   return [...fn(left), pivot, ...fn(right)]
      // }

      // 插入排序 将每个元素跟已排序队列（i之前的也就是便利过的 就是已排序队列）进行比较、插入
      // function fn(arr) {
      //   for (let i = 1, { length } = arr; i < length; i ++) {
      //     for (let j = 0; j < i; j ++) {
      //       if (arr[i] < arr[j]) {
      //         arr.splice(j, 0, arr.splice(i, 1)[0])
      //       }
      //     }
      //   }
      // }

      // 归并排序：找一个中间点 将左右两个数组分别递归归并
      // 思想：将数列递归两两拆分，拆分至每一组数列最小长度为1，分别进行处理为从小到大排列，再进行两两合并（两两拆分 => 两两合并(合并函数功能为将两个数组合并成从小到大排列，每个数组最小粒度为1)）
      // function fn(arr) {
      //   if (arr.length <= 1) {
      //     return arr
      //   }
      //   const mid = Math.floor(arr.length / 2)
      //   const left = arr.slice(0, mid)
      //   const right = arr.slice(mid)

      //   return merge(fn(left), fn(right))  // 写一个类似原生的简单方法当作原生用

      //   function merge(a, b) {
      //     const { length: aLength } = a
      //     const { length: bLength } = b
      //     const c = []
      //     let i = 0, j = 0

      //     while (i < aLength && j < bLength) {
      //       if (a[i] < b[j]) {
      //         c.push(a[i ++])
      //       } else {
      //         c.push(b[j ++])
      //       }
      //     }
      //     while (i < aLength) {
      //       c.push(a[i ++])
      //     }
      //     while (j < bLength) {
      //       c.push(b[j ++])
      //     }
      //     console.log('将', a, '和', b, '合并为', c)
      //     return c
      //   }
      // }

      // log(fn(arr))
      // log(arr)


      // 去重并记录出现最多的元素次数
      // var str = 'hkajfahfauhtasaabua';
      // let max = 0
      // let maxItem
      // console.log([...str].reduce((prev, next) => {
      //   const item = prev[next]
      //   if (item === undefined) {
      //     prev[next] = 0
      //   } else {
      //     const value = item + 1
      //     prev[next] = value
      //     if (value > max) {
      //       max = value
      //       maxItem = next
      //     }
      //   }
      //   return prev
      // }, {}))
      // console.log(max)
      // console.log(maxItem)


  

    

    
    // 禁用鼠标事件属性：pointer-events: none;
    // UI开发调试：outline: 1px #000 solid;
    // 禁止用户选择：
      // -webkit-touch-callout: none;
      // -webkit-user-select: none;

    // 热加载：监听本地文件修改，服务器推送到客户端，将更新补丁通过前端API调用实现重新加载

    // const createPromise = (time, id) => () =>
    //   new Promise(solve =>
    //     setTimeout(() => {
    //       console.log("promise", id);
    //       solve();
    //     }, time)
    //   );
    // function runPromiseByQueue(myPromises) {
    //   myPromises.reduce(
    //     (prev, next) => prev.then(() => next()),
    //     Promise.resolve()
    //   );
    // }
    // async function runPromiseByQueue(promises) {
    //   for(let promise of promises) {
    //     await promise()
    //   }
    // }
    // runPromiseByQueue([
    //   createPromise(3000, 1),
    //   createPromise(2000, 2),
    //   createPromise(1000, 3)
    // ])
    // createPromise(3000, 1)()
    //   .then(() => 
    //     createPromise(2000, 2)()
    //   )
    //   .then(() => 
    //     createPromise(1000, 3)()
    //   )


    // 移动端 1rem === 100px 解决方案
    // document.documentElement.style.fontSize = screen.width / 3.75 + 'px'
    // document.documentElement.style.fontSize = 100 / 375 * 100 + 'vw' // 26.6667
    // document.documentElement.style.fontSize = screen.width * (100 / 375) + 'px'

    

    // hooks 设计动机：
    // 1. class类难以理解（牵强）
    // 2. 组件逻辑复用困难 class组件复用方式会形成嵌套地狱 
      //  hooks提供自定义hook
    // 3. 逻辑复杂：同一个生命周期可能会包含很多互不相关的逻辑 而且相当一部分逻辑会被生命周期拆分开 
      //  hooks将相互关联的逻辑组合到一起

    




    // ES7  
    // Array.prototype.includes
    // 3 ** 2 // 9
    // ES8
    // async await 
    // Object.values entries getOwnPropertyDescriptors
    // 共享内存和原子


    // 真正意义的浅拷贝
    // Object.create(
    //   Object.getPrototypeOf(o),
    //   Object.getOwnPropertyDescriptors(o)
    // )

    // const Singleton = (function Wrap() {
    //   let instance
    //   function Singleton() {
    //     if (!instance) {
    //       return instance = this
    //     }
    //     return instance
    //   }
    
    //   return Singleton
    // })()

    // const Singleton =  function () {
    //   if (!Singleton.instance) {
    //     return Singleton.instance = this
    //   }
    //   return Singleton.instance
    // }

    // const a = new Singleton()
    // const b = new Singleton()

    // log(a === b)





    // function promisify(targetFunc) {
    //   return function (...args) {
    //     return new Promise((rl, rj) => {
    //       args.push(function callback(err, ...data) {
    //         if (err) {
    //           return rj(err)
    //         }
    //         rl(...data)
    //       })
    //       targetFunc.apply(this, args)
    //     })
    //   }
    // }

    // const fsp = new Proxy(fs, {
    //   get(target, key, r) {
    //     return promisify(target[key])
    //   }
    // })

  

    // new实现
    // function customNew(constructor, ...rest) {
    //   // 1.
    //   const instance = Object.create(constructor.prototype)
    //   // 2.
    //   // const instance = {}
    //   // Object.setPrototypeOf(instance, constructor.prototype)

    //   const ret = constructor.apply(instance, rest)
    //   return ret || instance
    // }

    // function S() {
    //   // 实例继承1.
    //   F.call(this)
    // }
    // function F() {}

    // // 原型继承1.  // 会丢失S的原型属性
    // S.prototype = Object.create(
    //   F.prototype, 
    //   {
    //     // 设置prototype.constructor 1.
    //     constructor: {
    //       value: S,
    //       enumerable: false,  // 是否可枚举，默认为true
    //       configurable: true, // 是否可配置（delete 更改描述属性）
    //       writable: true,     // 是否可写，默认为true
    //     },
    //     // 设置prototype.constructor 2.
    //     // constructor: Object.getOwnPropertyDescriptor(S.prototype, 'constructor')
    //   }
    // )

    // // 原型继承2.  // 不会丢失S原型属性
    // // Object.setPrototypeOf(S.prototype, F.prototype)
    // // S.prototype.__proto__ = F.prototype

    // // 静态继承
    // Object.setPrototypeOf(S, F)

    // const s = new S()

    // // 实例继承2.
    // F.call(s)

    // log(s)


    // 原型链继承：S.prototype = new F() 将构造函数的原型设置为另一个构造函数的实例对象
    // 构造继承：F.call(s = new S()) 绑定子类实例调用父类构造器，继承父类实例属性
    // 寄生式继承：创建一个空Constructor 让其prototype = F.prototype | {}(主要用于继承字面量对象); 返回 new Constructor() | Object.create(F.prototype)
    // 组合式继承：原型链继承 + 构造继承 
    // 寄生组合式继承：寄生式继承 + 组合式继承 将S.prototype = 寄生式继承的返回  解决1.父类构造器被调用两次 2.父类实例被继承两次


    // function F() {
    //   log('F')
    //   this.a = 1
    // }
    // F.prototype.b = 2

    // function S(sup) {
    //   sup.call(this)
    // }

    // function EmptyConstructor() {}

    // EmptyConstructor.prototype = F.prototype

    // const o = Object.create(F.prototype)

    // S.prototype = new EmptyConstructor() || o

    // const s = new S(F)
    // log(s)

    //
    // 1. 传参方式不通 URL RequestBody
    // 2. GET有参数长度限制 POST没有
    // 3. GET请求会被浏览器主动缓存 POST需手动设置
    // 4. GET请求参数会被保存在历史记录 POST不会


    // 跨域
    // 1. JSONP
    // 2. CORS (Access-Control-Allow-Origin)
    // 3. doucment.domain = 'taobao.com' (二级域名相同)
    // 4. window.name + iframe跨域
    // 5. 反向代理(框架+webpack)
    // 6. 搭建服务器代理做中间层(node中间件) 绕过浏览器
    // 7. postMessage跨域
    // 8. WebSocket协议跨域


    // html5
    // 1. 本地存储 webStorage local/sesision
    // 2. 地理定位 navigator.geolocation.getCurrentPosition()
    // 3. 新增语义化标签header footer nav article section / 新增canvas video audio标签 / 新增表单控件类型 url number time search date email
    // 4. webSocket / webWork
    // 5. 拖拽 drag / drop
    // 6. FileReader
    // 7. navigator.onLine   online   offline
    // 8. requestFullScreen() 开启全屏显示 / cancelFullScreen() 关闭全屏显示
    // 9. 离线缓存 Service workers
      // 拖拽元素
      // 1.drag 应用于拖拽元素，整个拖拽过程都会调用
      // 2.dragstart应用于拖拽元素，当拖拽开始时调用
      // 3.dragleave应用于拖拽元素，当鼠标离开拖拽元素时调用
      // 4.dragend应用于拖拽元素，当拖拽结束时调用
      // 目标元素
      // 1.dragenter应用于目标元素，当拖拽元素进入时调用
      // 2.dragover应用于目标元素，当停留在目标元素上时调用 阻止浏览器的默认禁止行为（event.preventDefault）
      // 3.drop应用于目标元素，当在目标元素上松开鼠标时调用
      // 4.dragleave应用于目标元素，当鼠标离开目标元素时调用
    
    

    // css3
    // 选择器
    // border-radius border-image box-shadow
    // background-origin size clip 
    // 渐变属性 线性渐变 径向渐变
    // 文本效果 Text
    // @font-face 在线使用字体 图标
    // 2D 3D 转换 transform
    // 过渡 transition
    // @keyframes
    // 多列
    // 弹性盒 flexbox
    // box-sizing
    // vh vw


    // pointer-events: none; 阻止元素任何JS事件

    // // 水平居中
    // 1. text-align：center（子元素：字符串 行内元素 行内块元素）
    // 2. margin：auto(块元素 有宽度)
    // 3. flex + 主侧轴 | 子元素margin：auto
    // 4. position + thransform: thranslate()
    // // 垂直居中
    // 1. line-height：（单行 行内元素 行内块元素）
    // 2. 父：line-height / font-size : 0 子：vertical-align：middle
    // 3. flex
    // 4. position + thransform / margin-left + thransform
    // 5. 父元素（diaplay：table） 子元素（display：table-cell vertical-middle）


    // JSON.stringify()
    // 作为对象属性 会忽略 function undefined Symbol (NaN 正负无穷Inifinty 会转为null)
    // 在数组内 以上项都会转为null
    // 存在循环引用会抛出错误


    // 代码复用：1. 函数封装 2. 继承  react：1. HOC 2. render Prop 3. 自定义hooks 4. providers consumers


    // 一次完整的HTTP请求过程
    // 1. 对URL进行DNS域名解析，得到对应的IP地址
    // 2. 根据IP找到对应服务器，发起TCP的三次握手
    // 3. 建立TCP连接后发起HTTP请求
    // 4. 服务器响应HTTP请求，浏览器得到HTML代码
    // 5. 浏览器渲染

    // 浏览器渲染过程
    // 1. 构建 DOM Tree & CSSOM Tree（样式表对象模型）；CSSOM 和 DOM 二者无关联，是各自独立的树 
    //   DOM：描述了文档节点之间的结构和属性
    //   CSSOM：描述了标签样式
    //     每一个浏览器都会有一个 “浏览器自定义样式（user agent styles）”，也就是说如果我们不提供自定义样式的话，我们的页面将会按照浏览器提供的样式来渲染
    // 2. 将两棵树组合成 Render Tree
    //   render Tree 和 DOM Tree区别：
    //     render Tree中包含节点对应的样式；
    //     render Tree中不包含display: none的节点和head节点
    //   (display：none会触发reflow visibility：hidden只会触发重绘因为位置没有发生变化)
    // 3. layout（计算布局过程） 
    //   有了Render Tree 浏览器已经能知道文档结构的从属关系和它们所对应的样式了 从而计算出每个节点在屏幕中的位置
    // 4. painting按照计算出来的规则 画到屏幕上
    // 3.4两步也可以叫做回流

    // CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。
    // 通常情况下 DOM 和 CSSOM 是并行构建的，
    //   但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时， DOM 构建将暂停，
    //   如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，
    //   所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。

    // 回流(reflow) & 重绘(repaint)
    // 回流：当render Tree中一些节点因尺寸，布局，隐藏，内容等改变需要重新构建，这时浏览器会重新构造这部分渲染树
    // 重绘：回流完成后，浏览器会重新绘制改变的部分和受影响的部分到屏幕中；或者NODE需要更改的属性只会影响外观而不会影响布局(非几何属性)，会触发重绘 重新绘制受改变的部分元素
    // 回流一定会发生重绘 重绘不一定会引发回流

    // 浏览器会优化回流和重绘操作：浏览器会维护一个队列，将回流和重绘操作放入这个队列，等队列中的操作到了一定数量或者到了一定时间就会进行一个批操作
    // 自己的优化：批操作 直接改变className或cssText累加或setAttribute('style')；DOM元素批添加
    

    // HTTP请求方式
    // 1、OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性
    // 2、HEAD 向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。
    // 3、GET 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url
    // 4、POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form
    // 5、PUT 向指定资源位置上传其最新内容
    // 6、DELETE 请求服务器删除Request-URL所标识的资源
    // 7、TRACE 回显服务器收到的请求，主要用于测试或诊断
    // 8、CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
    // 注意：
    // 1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。
    // 2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。

    // 请求头

    // response 状态码
    // 1XX－信息类(Information),表示收到Web浏览器请求，正在进一步的处理中，例如post请求
    // 2XX－成功类（Successful）,表示用户请求被正确接收，理解和处理例如：200 OK
    // 3XX-重定向类(Redirection),表示请求没有成功，客户必须采取进一步的动作。
    // 4XX-客户端错误(Client Error)，表示客户端提交的请求有错误 例如：404 NOT Found，请求资源不存在。
    // 5XX-服务器错误(Server Error)表示服务器不能完成对请求的处理：如 500

    // 100: post请求 发送header确认是否可以访问
    // 200: OK
    // 304: 自上次请求资源没有发生变化 可以使用缓存
    // 404: 请求资源不存在
    // 500: 服务端错误



    // 抽象语法树AST：它表示了源代码所对应的数据结构。
    // 编译型语言 & 解释型语言：计算机并不能直接识别高级语言 只能理解机器语言，执行前必须把高级语言翻译成机器语言。
    //  翻译的方式有两种：两种方式只是翻译的时间不同
    //    编译型语言写的程序在执行前 需要有一个专门的编译过程 把程序编译成计算机语言文件 以后运行的话就不需要重新翻译了 直接使用编译结果
    //    解释型语言在程序执行的时候才翻译(边执行边编译)
    // 传统的编译语言在执行前会经历三个步骤：统称为“编译”
    //  1. 分词/词法分析：将字符串分解成有意义的代码块（词法单元）
    //  2. 解析/语法分析：语言引擎配合编译器将词法单元转换成抽象语法树
    //  3. 代码生成：基于AST生成可执行代码的过程



    // 滑动
    // father: white-space: nowrap; overflow: hidden;
    // chidren: display: inline-block;

    // Promise: then catch 方法会默认返回一个最终 promiseStatus 为 resolved 的 new Promise resolve(returnValue)

    // const promise = new Promise((resolve, r) => {
    //     // setTimeout(resolve, 1000, 'succ')
    //     setTimeout(r, 1000, 'err')
    //      throw 也相当于reject
    //   })
    //     // .catch(err => {
    //     //   // throw new Error('catch')
    //     //   return 2222
    //     // })
    
    // async function fn() {
    //   // async会返回一个promise 它的最终状态是根据内部await拿到的状态决定的
    //   //    如果有一个await接收到了reject状态 那么此函数的promise直接返回reject并return(除非捕获异常到了try catch)
    //   //    如果所有await执行完毕并没有接收到reject状态 那么此函数的promise返回resolved(returnValue); 如果return值为Promise，那么此函数返回值为此promise而不是async的promise
    //   const res = await promise
    //   log('resolving') // await如果不返回resolve状态（返回reject或者不返回这两个状态也就是pending状态） 会直接return此promise 所以这行代码及以后的不执行
    //   return res // resolve(res)
    // }

    // async function fn() {
    //   const a = new Promise((rs) => { setTimeout(rs, 2000, 1) })
    //   const b = new Promise((rs) => { setTimeout(rs, 2000, 2) })

    //   // async函数内promise不依赖执行
    //   // 方式1
    //   // const retA = await a
    //   // const retB = await b
    //   // 方式2
    //   // const [retA, retB] = await Promise.all([a, b])

    //   // log(retA, retB)
    // }

    // const f = fn()

    // log(f)

    // f
    //   .then(res => {
    //     log('then')
    //     log(res)
    //   })
    //   .catch(err => {
    //     log('catch')
    //     log(err)
    //   })


    // 让await接收到rejected状态也继续往下执行
    // async function asyncWrapper(promise) {
    //   try {
    //     const res = await promise
    //     return [null, res]
    //   } catch (e) {
    //     return [e, null]  // 捕获await接收到的rejected 让它不返回此状态（返回一个成功状态）给yield函数的next().value.catch(让它给.then)
    //   }
    // }
    
    // const f = asyncWrapper()

    // f.then(res => log(1, res)).catch(err => log(2, err))

    

    // Generator: 状态机, 还是一个遍历器对象生成函数
    // 调用它：返回一个指向内部状态的指针对象, 还是一个遍历器对象
    // 调用next 移动内部指针 返回当前阶段的信息

    // function* fn() {
    //   yield 1
    //   yield 2
    //   return 3 // {value: 3, done: true}: for of 不会遍历3（遍历到true就不返回了）
    // }

    // const f = fn()

    // for(let value of f) {
    //   log(value)
    // }

    // yield*命令可以很方便地取出嵌套数组的所有成员。
    // function* iterTree(tree) {
    //   if (Array.isArray(tree)) {
    //     for(let i=0; i < tree.length; i++) {
    //       yield* iterTree(tree[i]);
    //     }
    //   } else {
    //     yield tree;
    //   }
    // }

    // const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];

    // for(let x of iterTree(tree)) {
    //   console.log(x);
    // }

    // [...iterTree(tree)]

    // Generator 异步应用（async函数实现原理）
    // function run(gen){
    //   var g = gen();

    //   function next(data){
    //     var result = g.next(data);
    //     if (result.done) return result.value;
    //     result.value.then(function(data){
    //       next(data);
    //     });
    //   }



    //   next();
    // }

    // run(gen);
  


    // Iterator遍历器：是一种接口，为各种不同的数据结构提供统一的访问机制
      // 使得数据结构的成员能够按某种次序排列
      // 供for...of消费

    // 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）

    // Array
    // Map
    // Set
    // String
    // TypedArray
    // 函数的 arguments 对象
    // NodeList 对象

    // 会默认调用iterator的方法：for of;  解构赋值; 扩展运算符; yield* [] || foo(); Array.from(); Promise.all()

    // const o = {
    //   a: 1,
    //   b: 2,
    //   c: 3,
      // [Symbol.iterator]() {
      //   const values = Object.values(this)
      //   let count = 0
      //   return {
      //     next: () => {
      //       const cur = values[count ++]
      //       return {
      //         value: cur,
      //         done: !cur
      //       }
      //     }
      //   }
      // }
    //   * [Symbol.iterator]() {
    //     for (let key in this) {
    //       yield this[key]
    //     }
        // const values = Object.values(this)
        // yield * values
    //   }
    
    // }

    // const iterator = o[Symbol.iterator]()

    // log(iterator.next())
    // log(iterator.next())
    // log(iterator.next())
    // log(iterator.next())

    // log([ ...o ])

    // for (let key of o) {
    //   log(key)
    // }


    // function* entries(obj) {
    //   for (let key of Object.keys(obj)) {
    //     yield [key, obj[key]];
    //   }
    // }

    // for (let [key, value] of entries(obj)) {
    //   console.log(key, '->', value);
    // }
  
    // 链表 VS 数组
    // 链表： 1. 内存上存储：不需要连续空间
    //       2. 增删：效率高
    //       3. 读取：效率低（因为要从head开始遍历）

    // 数组： 1. 内存上存储：是一块连续的区域
    //       2. 增删：效率低（因为所操作的索引之后的元素都要移动）
    //       3. 读取：效率高（因为内存中是连续的 知道每一个元素的内存地址）


    // 上移下移
    // const arr = [1,2,3,4,5]

    // function fn(i, t) {

    //   if (i < t) {
    //     t -= 1
    //   }
      
    //   arr.splice(t, 0, ...arr.splice(i, 1))
    // }

    // fn(2, 4)


    
    // Object.is()，其行为与===基本一致，不过有两处不同：

    // +0不等于-0。
    // NaN等于自身。

		

		// js 文本框监听粘贴事件，获取粘贴板上的图片实现预览:  在事件对象e.clipboardData.items(arr)下
		// 虽然使用的 HTML 元素都支持 onpaste 事件，但实际上并非支持所有元素，例如 <p> 元素， 除非设置了 contenteditable 为 "true" 
		

			// document.body.oncopy = (e) => {
				
			// 	return true
			// }

    // DOM

    // box => HTMLDivElement => HTMLElement => Element => Node => EventTarget => Object

    // clientLeft/Top：padding到border的距离
    // clientWidth/Height：元素宽度（不包含border）

    // offsetLeft/Top：和最近父元素的距离
    // offsetWidth/Height：元素宽度（包含border）

    // scrollWidth/Height：同client
    // scrollLeft/Top：元素内滚动距离

    // window.innerHegiht/Width：视口大小
    // window.screen.height/width：客户端分辨率

    // event:
    // offsetX/Y：相对于事件源的鼠标距离
    // clientX/Y：相对于浏览器视口的鼠标距离
    // screenX/Y：相对于屏幕的鼠标距离

    // dom.getBoundingClientRect()：返回4个属性 距离浏览器视口的距离
    




    
    // console.log(ul.getElementsByTagName('*'))   //子孙节点
    // console.log(ul.querySelector('*'))          //子孙节点
    // console.log(ul.children | childNodes)                    //子节点

		// const box = document.getElementById('box')
		// const element = document.createElement('div')
		// const attribute = document.createAttribute('id')
		// const text = document.createTextNode(`yyy`)

		// log(element.nodeType)		// 1
		// log(attribute.nodeType)	// 2
		// log(text.nodeType)			// 3
		// log(document.nodetype) // 9

		// log(element.nodeName)		// DIV: 标签名大写
		// log(attribute.nodeName)	// id: 属性名
		// log(text.nodeName)			// '#text': 始终为#text
		// log(document.nodeName) // '#document': 始终为

		// log(element.nodeValue)	// null: 始终为null
		// log(attribute.nodeValue)// 对应属性值attribute.nodeValue = 'box'
		// log(text.nodeValue)			// 'yyy'
		// log(document.nodeValue) // null: 始终为null

		// getAttribute()	// 不存在返回null
		// setAttribute()
		// removeAttribute()

		// 查看元素是否有孩子节点更便捷的方法
		// hasChildNodes() === nodeList.childNodes.length

		// 如果传入到 appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置 转移到新位置。即使可以将 DOM 树看成是由一系列指针连接起来的，但任何 DOM 节点也不能同时出 现在文档中的多个位置上。因此，如果在调用 appendChild()时传入了父节点的第一个子节点，那么 
		//someNode 有多个子节点
		// const returnedNode = someNode.appendChild(someNode.firstChild)
		// log(returnedNode === someNode.firstChild) //false
		// log(returnedNode === someNode.lastChild) //true

		// appendChild()
		// insertBefore()
		// replaceChild()
		// removeChild()
		// cloneNode() // true: 深克隆 同时克隆其子节点; false 浅克隆 只克隆节点本身
		// normalize() // 这个方法唯一的作用就是处理文档树中的文本节点。 由于解析器的实现或 DOM 操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点 的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了 空文本节点，则删除它;如果找到相邻的文本节点，则将它们合并为一个文本节点

		// log(document.referrer) // 取得来源页面的URL
    

    // 使元素滚动至视口
    // document.querySelector('input').scrollIntoView(true)

    // 判断节点是不是另一个节点的子节点
    // document.documentElement.contains(document.body) // true
    // document.body.parentNode === document.documentElement // true


    // 修改 className 时，如果新类关联了与此前不同的 CSS 样式，那么就会立即应用新的样式。
    // div#box | p.box | [title] | [title][name] | div [title] | div td > p | div td + p | a.red :visited

		// 动态添加样式：1. 动态创建style标签, createTextNode到标签内, 添加到head中；2. 动态创建link标签引入(createElement('link'))；
    // script同理。
    
    // 批量读写css样式
    // Object.assign(myDiv.style, { // 假批量
    //   color: '#f00'
    // })

    // myDiv.style.cssText  // 可读写

    // myDiv.getArrtibute('style')  // 可读写 set

    // 行内样式 & 内联样式
    // window.getComputedStyle(mtDiv, null) // {}   // 只读

    // classList 属性是新集合类型 DOMTokenList 的实例
		// add(value):将给定的字符串值添加到列表中。如果值已经存在，就不添加了
		// remove(value):从列表中删除给定的字符串
    // toggle(value):如果列表中已经存在给定的值，删除它;如果列表中没有给定的值，添加它


    // css三大特性：继承性 层叠性 优先性
    // 继承：text-，font-，line-，color
    // 优先性：权重。!important ∞；行内样式 1000；id 100；class 10；元素 1；
    // 层叠：相同样式后面定义的覆盖前面定义的 不同样式会重叠生效

    // sass:
    // 声明变量 $w: 5px !global;
    // @import "rounded-corners", "text-shadow", "url", url(""); @import可以内嵌
    // .a { @extends .className }
    // $grid-width: 40px;
    // $gutter-width: 10px;
    // @function grid-width($n) {
    //   @return $n * $grid-width + ($n - 1) * $gutter-width;
    // }
    // #sidebar { width: grid-width(5); }

    // <div>
    //   <img />
    // </div>
    // img {
    //   left: 50%;  // 先偏移父元素的一半 再偏移子元素的一半使子元素X轴居中; 这样在窗口缩小 父元素width小于子元素宽度时 子元素在不改变width的情况下还能X轴居中
    //   transform: translateX(-50%);
    // }

    // DOM事件流
    // 捕获阶段 - 目标阶段 - 冒泡阶段

    // document.createDocumentFragment() ： 创建一个文档片段占位符 最后只需要一次现场更新 && 渲染DOM

    // ontextInput
    // onDOMNodeRemoved onDOMNodeInsertedIntoDocument event.relatedNode属性中包含一个对父级节点的引用

    // postMessage(数据, 发送页面源地址); onmessage 接收事件 参数：data，origin，source

		// DOM焦点
		// document.activeElement 属性，这个 属性始终会引用 DOM 中当前获得了焦点的元素
		// document.hasFocus()

		// 当前选择的内容
		// window.getSelection().toString()


		// try catch 做兼容小技巧
		// function convertToArray(nodes){
		// 	let array = null
		// 	try {
		// 		array = Array.prototype.slice.call(nodes, 0) //针对非 IE 浏览器
		// 	} catch (ex) {	
		// 		array = []
		// 		for (let i=0, len=nodes.length; i < len; i++){
		// 			array.push(nodes[i])
		// 		}
		// 	}
		// 	return array
		// }


		// 监听函数是否被调用
		// function fn () {	// 全局函数
		// 	console.log('function var')
		// }
		
		// const obj = {	// 对象内函数
		// 	name: 'obj',
		// 	fn(a, b) {
		// 		console.log(a, b)
		// 	}
		// }

		// Object.prototype.monitor = function(targetName, listenerBefore = () => true, listenerAfter) {
		// 	this[targetName] = function() {
		// 		if (listenerBefore() === true) {
		// 			this[targetName].apply(this, arguments)
		// 			listenerAfter && listenerAfter()
		// 		}
		// 	}
		// }

		// obj.monitor('fn', () => true, () => console.log('done'))
		// obj.fn(1, 2)

		// monitor('fn', () => true, () => console.log('done'))
		// fn()




	// 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）
	// 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了
	// 这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录
		// function fn(num) { 
		// 	if(num == 1) return 1
		// 	return n * arguments.callee(num - 1)
		// }
		// 5 * (4 * (3 * (2 * 1)))
		// function fn(num, total) {
		// 	if (num == 1) return total
		// 	return arguments.callee(num - 1, total * num)
		// }
		// log(fn(5, 1))


		// 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。
		// function currying(fn, n) {
		// 	return function (m) {
		// 		return fn.call(this, m, n);
		// 	};
		// }
		// 第二种方法就简单多了，就是采用ES6的函数默认值。
		// function factorial(n, total = 1) {
		// 	if (n === 1) return total;
		// 	return factorial(n - 1, n * total);
		// }

		// factorial(5)

		// function tailFactorial(n, total) {
		// 	if (n === 1) return total;
		// 	return tailFactorial(n - 1, n * total);
		// }

		// const factorial = currying(tailFactorial, 1);

		// factorial(5) // 120

	// // rest: 剩余参数
	// function fn({ a, ...rest }) {
	// 	log(rest)	// { b: 2, c: 3 }
	// }
	// fn({ a: 1, b: 2, c: 3 })

	// 设置函数参数必传小技巧
	// function err(params) {throw new Error(params + 'is required')}
	// function fn(params = err('params')) {}
	// fn()

// 子代 不同于 后代
// document.querySelector('input[type=file]').files[0];
// document.querySelectorAll("div.note, div.alert")
// document.querySelector("#my-id").querySelectorAll("img")

// React 标准化了事件对象，因此在不同的浏览器中都会有相同的属性

// 二叉查找树，也称二叉搜索树，或二叉排序树。其定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：
// （1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
// （2） 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
// （3） 任意节点的左、右子树也分别为二叉查找树；
// （4） 没有键值相等的节点。

// 红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
// 性质1. 节点是红色或黑色。
// 性质2. 根节点是黑色。
// 性质3 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
// 性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

	// // 二叉树遍历
	// const tree = {
	// 	value: "tree",
	// 	left: {
	// 		value: '1',
	// 		left: {
  //       value: '2',
	// 		},
	// 		right: {
	// 			value: '3',
	// 			left: {
	// 				value: '4',
	// 			},
	// 			right: {
	// 				value: '5',
	// 			}
	// 		}
	// 	},
	// 	right: {
	// 		value: 'a',
	// 		left: {
	// 			value: 'b',
	// 		},
	// 		right: {
	// 			value: 'c',
	// 			left: {
  //         value: 'd',
	// 			},
	// 			right: {
  //         value: 'e',
	// 			}
	// 		}
	// 	}
	// }
  // let result = []
  // let dp = 0

  // 结构深度
  // function dfs(tree, d = 0) {
  //   if (tree) {
  //     const { left, right } = tree
  //     if (!left && !right) {
  //       dp = d
  //     }
  //     dfs(left, d + 1)
  //     dfs(right, d + 1)
  //   }
  // }
  // dfs(tree)
  // log(dp)

  // 中序：21435 tree badce
  // 先序：tree 12345 abcde
  // 后序：24531 bdeca tree



	// // myBfs
	// function fn(data) {
	// 	if (typeof data !== 'object') return
	// 	for	(let key in data) {
	// 		if (key === 'value') {
	// 			result.push(data.value)
	// 		} else {
	// 			fn(data[key])
	// 		}
	// 	}
	// }
	// fn(tree)
	// log(result)

	// // 深度遍历
	// function dfs(item) {
	// 	if (item) {
	// 		dfs(item.left)
	// 		result.push(item.value)
	// 		dfs(item.right)
	// 	}
	// }
	// dfs(tree)
	// log(result)
	// // 广度遍历
	// let result = []
	// let stack = [tree] // 先将要遍历的树压入栈
	// let count = 0 // 用来记录执行到第一层
	// let bfs = function () {
	// 	let node = stack[count]
	// 	if (node) {
	// 		result.push(node.value)
	// 		if (node.left) stack.push(node.left)
	// 		if (node.right) stack.push(node.right)
	// 		count ++
	// 		bfs()
	// 	}
	// }
	// bfs();
	// log(stack)
	// log(count)
	// console.log(result)
		

		// let o = {
    //   a: {
    //     b: {}
    //   },
    //   c: {
    //     d: {
    //       e: {},
    //       f: {
    //         g: {
    //           x: 'x'
    //         }
    //       },
    //       h: {
    //         i: 'i'
    //       }
    //     }
    //   },
    //   j: {
    //     k: 'j'
    //   }
    // }

    // o = {
    //   a: {
    //     b: {
    //       c: 'c'
		// 		},
		// 		x: {}
    //   },
    //   d: {
    //     e: 'e'
    //   },
    //   f: {
    //     g: {
		// 			h: {
		// 				k: 'k'
		// 			}
		// 		}
    //   }
		// }

		// // 深度遍历
		// let a
		// function fn(obj) {
		// 	if (typeof obj == 'object') {
		// 		for (let key in obj) {
		// 			log(key)
		// 			if (fn(obj[key]) == 'e') {
		// 				a = obj[key]
		// 				return 'e'
		// 			}
		// 		}
		// 	}
		// 	return obj
		// }
		// 广度遍历
		// let data = [o]
		// let count = 0
		// function fn() {
		// 	const node = data[count]
		// 	if (node && typeof node === 'object') {
		// 		for (let key in node) {
		// 			log(key)
		// 			const item = node[key]
		// 			if (typeof item === 'object') {
		// 				data.push(item)
		// 			}
		// 			if (item == 'e') {
		// 				return node
		// 			}
		// 		}
		// 	}
		// 	count ++
		// 	return fn()
		// }
		// log(fn(data))
		// log(count)
		// log(data)

		// // 实例原型优先级 && 覆盖
		// class Ft {
		// 	constructor() {
		// 		// this.a = () => {log('ft-实例')}
		// 		this.ft = 'ft'
		// 	}

		// 	static st1 = 'st'
		// 	static st2() {log('st')}

		// 	a() {log('ft-原型')}
		// }

		// class Fn extends Ft {
		// 	constructor(props) {
		// 		super(props)
		// 		// this.a = () => {log('实例')}
		// 	}

		// 	a() {log('原型')}
		// }


		// const f = new Fn()

		// log(f)
		// f.a()

		// log(Object.getPrototypeOf(f) === Fn.prototype)
		// log(Object.getPrototypeOf(Fn.prototype) === Ft.prototype)
		// log(Object.getPrototypeOf(Ft.prototype) === Object.prototype)

		// log(Ft.st1)
		// Ft.st2()

		// log(Fn.st1)
		// Fn.st2()

		// log(Object.getPrototypeOf(Fn) === Ft.prototype)



		//解构加拓展运算符

		// 数组解构
		// const [ a, ...b ] = [ 1, 2, 3 ]
		// console.log(b)// [2,3]
		// 对象解构
		// const { a, defaulT: d = 'default', ...b } = { a:1, b:2, c:3 }
		// console.log(b,d)// {b:2}, 'default'
		// 字符串解构
		// const str = 'abcd'
		// const [ a, b, ...c ] = str
		// const { length: le } = str
		// console.log(a,b,c,le)// a,b,['c','d'],7
		// 函数变量解构
		// function fn({ component: C = 'default', ...rest }, ...n){
		//   console.log(C, rest, n)// 'component', {b:2,c:3}, ['a'] //参数arguments其实是一个数组
		// }
		// fn({ component: 'component', b:2, c:3 }, 'a')
		// function fn([ a, b, ...c]){
		//   console.log(a,b,c)// 1,2,[3,4]
		// }
		// fn([1,2,3,4])

		// document.onclick = (function() {
		// 	// 事件自调用，函数内代码只会运行一次
		// 	log(1)
		// 	var div = null	// 闭包变量
		// 	return function() {
		// 		// 每点击一次都会运行的部分
		// 		if (!div) {
		// 			// 只第一次点击会运行的部分，因为闭包变量
		// 			log(3)
		// 			div = 1
		// 		}
		// 		log(2)
		// 		return div
		// 	}
		// })()

		// // 遍历数组
		// const arr = [1,2,3,4,5]
		// for (let i = 0, item; item = arr[i ++]; ) {
		// 	log(item)
		// }


		// NaN.toString() == 'NaN' || Number.isNaN() == true  判断是否为NaN
		// true.toString() === 'true' 判断是否为true
		
		// 实现钱币 100.00  number.toFied(2)

		// 隐式类型转换规则
		// null == undefined 和自己; 除此之外不和任何类型 ==
		// ①、如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
		// ②、如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值
		// ③、如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较
		// const a = {
		// 	i: 0,
		// 	valueOf: function() {
		// 		return ++ this.i
		// 	}
		// }
		// if (a == 1 && a == 2 && a ==3) {
		// 	console.log(1)
		// }

		// 刷新页面
		// window.location.href = window.locatin.href
		// window.location.replace = window.location.href
		// window.history.go(0) // back;forward
		// window.location.reload() // true 重新发送http请求获取最新页；默认false 从浏览器缓存读取数据
		// document.referrer

		// eval
		// eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。
		// 这里我使用eval() 来解析JSON字符串。
		// var dataObj=eval("("+data+")");//转换为json对象 
		// eval这里要添加"("+data+")" 一对小括号，原因在于：eval本身的问题。 由于json是以{}的方式来开始以及结束的，在JS中，它会被当成一个语句块来处理，所以必须强制性的将它转换成一种表达式。
		// 加上圆括号的目的是迫使eval函数在处理JavaScript代码的时候强制将括号内的表达式（expression）转化为对象，而不是作为语句（statement）来执行。

    



  // 0.1 + 0.2 === 0.30000000000000004 //15
  // 数据存储过程中的浮点数运算误差值：
  // 一种双精度浮点数编码方式导致的运算误差值


  // 1、如果两个值类型相同，进行 === 比较。
  // 2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： 
  // （1）如果一个是null、一个是undefined，那么[相等]。 
  // （2）如果任一值是字符串，另一个值是数值，在比较相等性之前先将字符串转换为数值；即是调用Number()函数。 
  // （3）如果任一值时布尔值，则在比较相等性之前先将其转换为数值，即是调用Number()函数。 数。 
  // （4）如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。



  
    // 锚点
    // <a >
    // el.scrollIntoView(boolean)
    // window.scrollTo(x, y)

    // 单行 多行
    // overflow: 'hidden',
    // textOverflow: 'ellipsis',
    // whiteSpace: "nowrap"

    // WebkitLineClamp: 1,
    // display: '-webkit-box',
    // wordBreak: 'break-all',
    // WebkitBoxOrient: 'vertical',



  // 斐波那契数列
  // 1 1 2 3 5 8 13 21
  // function fn(n, a = 1, b = 1) {
  //   if (n <= 2) return b
  //   return fn(n - 1, b, a + b)
  // }
  // function fn(n) {
  //   if (n <= 2) return 1 
  //   let a = 1
  //   let b = 1
  //   for(let i = 3; i <= n; i++ ) {
  //     [a, b] = [b, a + b]
  //   }
  //   return b
  // }



    // ts
    // 定义函数类型
    // interface fc {
    //   (a: number, b: number): number
    // }
    // let f: fc
    // f = (a, b) => a + b

    // const f: (a: number, b: number) => number | fc = (x, y) => a + b

    // const f = (a: number, b: number): number => a + b

    // 定义泛型
    // function identity<T>(arg: T): T {
    //   return arg;
    // }

    // let myIdentity: <U>(arg: U) => U = identity;
    // let myIdentity: { <U>(arg: U): U } = identity;

    // interface GenericIdentityFn {
    //   <T>(arg: T): T;
    // }
    // let myIdentity: GenericIdentityFn = identity;
    
    // interface GenericIdentityFn<T> {
    //   (arg: T): T;
    // }
    // let myIdentity: GenericIdentityFn<number> = identity;


    // JSDoc 也可用于对象： @property
    /**
      * Book类，代表一个书本.
      * @constructor 构造器
      * @param title {string} - 书本的标题.
      * @param {string} author - 书本的作者.
      * @param {callback} cb
      * @param { String[] | Array<string> } list
      * @param {string} [somebody=John Doe] - 可选参数和默认值
      * @returns {string|*}
      */
  
    // 触发事件
    // window.addEventListener('yy', (e) => log(e), true)

    // // 1.
    // const e = document.createEvent('Event')
    // e.initEvent('yy', true, true)
    // e.data = 'data'

    // // 2.
    // const e = new CustomEvent('yy', {
    //   detail: {
    //     data: 'data'
    //   }
    // })

    // window.dispatchEvent(e)


    // 节流和防抖：限制函数触发周期
    // 节流：规定周期内只执行一次(window.onscroll)
    // 防抖：操作完毕才执行(input onchange)

    // const f = () => log(1)

    // 节流
    // const throttle = (fn, interval) => {
    //   let time = 0
    //   return (...rest) => {
    //     const now = Date.now()
    //     if (now - time > interval) {
    //       time = now
    //       fn(...rest)
    //     }
    //   }
    // }

    // document.onmousemove = throttle(f, 1000)
    
    // 防抖
    // function fn(f, time) {
    //   let timeout
    //   return (...arg) => {
    //     clearTimeout(timeout)
    //     timeout = setTimeout(f, time, ...arg)
    //   }
    // }

    // 移动端模拟双击事件
    // function fn() {
    //   let time = 0
    //   return (e) => {
    //     time ++
    //     setTimeout(() => {
    //       time = 0
    //     }, 400)
    //     if (time > 1) {
    //       log(2)
    //     }
    //   }
    // }
    // function fn() {
    //   let time = 0
    //   return (e) => {
    //     if (Date.now() - time < 400) {
    //       time = 0
    //       log(2)
    //     } else {
    //       time = Date.now()
    //     }
    //   }
    // }
    // window.onclick = fn()

    // document.onclick = fn(f, 1000)

    



    // function fn() {
    //   const CSV = 'a,b\na,1\nb,2\n'
    //   var blob = new Blob(['\uFEFF' + CSV], {type: 'text/txt,charset=UTF-8'});
    //   url = URL.createObjectURL(blob)
    //   log(blob)
    //   const el = document.createElement('a')
    //   el.download = 'test.csv'
    //   el.href = url
    //   el.click()
    // }
    // fn()
    
    // 前端读取 & 导出excel： js-xlsx


    // BFC（Block Formatting Context）: 
    // 是一个页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然
    // 它决定了块级元素如何对它的子元素进行布局，以及其他元素与它的关系
    // 触发条件：
    // 1.float的值不为none
    // 2.overflow的值不为visible
    // 3.position的值不为static、releative
    // 4.display的值为table-cell、tabble-caption、inline-block
    // 5.display为 flex 或 inline-flex元素的直接子元素
    // 6.display为 grid 或 inline-grid 元素的直接子元素
    // 规则：
    // 1.浮动的元素会被父级计算高度（父级触发了BFC）
    // 2.非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）
    // 3.margin不会传递给父级（父级触发了BFC）
    // 4.两个相邻元素上下margin不会重叠（给其中一个元素增加一个父级，然后让他的父级触发BFC）


    // js清除浏览器缓存的几种方法

    
    // 线性结构转树型结构
    // const source = [
    //   { id: 1, title: 'hello', parent: 0 },
    //   { id: 2, title: 'hello', parent: 0 },
    //   { id: 3, title: 'hello', parent: 1 },
    //   { id: 4, title: 'hello', parent: 3 },
    //   { id: 5, title: 'hello', parent: 4 },
    //   { id: 6, title: 'hello', parent: 4 },
    //   { id: 7, title: 'hello', parent: 3 },
    //   { id: 8, title: 'hello', parent: 2 }
    // ]

    // function fn(arr, parent = 0) {
    //   const out = []

    //   arr.forEach(item => {
    //     if (item.parent === parent) {
    //       const children = fn(arr, item.id)
    //       if (children.length) {
    //         item.children = children
    //       }
    //       out.push(item)
    //     }
    //   })

    //   return out
    // }

    // log(fn(source))

    // function fn(arr, parent = 0) {
    //   return arr.filter(item => {
    //     const children = arr.filter(it => item.id == it.parent)
    //     if (children.length) {
    //       item.children = children
    //     }
    //     return item.parent === parent
    //   })
    // }

    // log(fn(source))

    // function fn(arr, parent = 0) {
    //   const out = []
    //   arr.forEach(item => {
    //     if (item.parent == parent) {
    //       const children = fn(arr, item.id)

    //       if (children.length) {
    //         item.children = children
    //       }

    //       out.push(item)
    //     }
    //   })
    //   return out
    // }

    // log(fn(source))


    // const registerCallBackUrl = `${window.location.href}&withCoupon=1${Object.keys(params).reduce((pre, next) => pre + `&${next}=${params[next]}`, '')}`

    // 严格模式 'use strict': 可以在作用域内部进行较为严格的错误条件检测
    // 1. 不允许意外创建全局变量 必须先声明后使用 不能delete删除var创建的变量
    // 2. 操作对象：对只读属性的对象赋值；对不可配置的对象delete；对不可拓展的对象添加属性
    // 3. 函数参数名不能重复；严格模式下arguments与参数完全独立：对参数重新赋值不会影响arguments
    // 4. this 始终指向指定的值（通过call apply bind），否则指向 undefined 而不指向window


    // 前端预览图片
    // 1. new FildReader().readAsDataURL(file).onload(info => info.result)
    // 2. window.URL.createObjectURL(blob)
    // 3. canvas => base64

    // new FormData().append('', file)

    // vue watch
      // const source = {
      //   demo: 1,
      //   demo2: 2
      // }
      // const temp = JSON.parse(JSON.stringify(source))

      // function watch(target) {
      //   const handleTarget = Object.keys(target).reduce((pre, key) => {
      //     pre[key] = {
      //       set: (value) => {
      //         target[key](value)
      //         temp[key] = value
      //       },
      //       get() {
      //         return temp[key]
      //       }
      //     }
      //     return pre
      //   }, {})
      //   Object.defineProperties(source, handleTarget)
      // }

      // watch({
      //   demo(value) {
      //     log('demo set', value)
      //   },
      //   demo2(value) {
      //     log('demo2 set', value)
      //   }
      // })

      // source.demo2 = 3

    


    // fetch
    // fetch('https://img.alicdn.com/tfs/TB1U1V4XeH2gK0jSZFEXXcqMpXa-1200-1200.png', {
    //   // method: "POST", // *GET, POST, PUT, DELETE, etc.
    //   // mode: "cors", // no-cors, cors, *same-origin
    //   // cache: "no-cache", // *default, no-cache, reload, force-cache, only-if-cached
    //   // credentials: "same-origin", // include, *same-origin, omit
    //   // redirect: "follow", // manual, *follow, error
    //   // referrer: "no-referrer", // no-referrer, *client
    //   // body: JSON.stringify(data), // body data type must match "Content-Type" header
    //   // headers: {
    //   //     // "Content-Type": "application/json",
    //   //     // "Content-Type": "application/x-www-form-urlencoded",
    //   //     // 'Cache-Control': 'no-cache'
    //   // },
    // })
    //   .then(res => res.blob())
    //   .then(res => {
    //     log(res)
    //     const url = URL.createObjectURL(res)
    //     log(url)
    //     document.querySelector('img').src = url
    //   })

    // var anotherRequest = new Request(myRequest, myInit)
    // // 这非常有用，因为请求和响应主体只是一个用途。制作这样的副本允许您再次使用请求/响应，同时init根据需要改变选项。必须在阅读正文之前制作副本，并且阅读副本中的正文也会在原始请求中将其标记为已读。
    // var myHeaders = new Headers();
    // myHeaders.append("Content-Type", "text/plain");

    // 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。

    // web 离线检测 navigator.onLine // boole
    // web 在线离线 事件 online offline

    // 表单 submit reset
    // <input type="reset" />
    // <button type="reset">Reset Form</button>

    // form.submit() // reset()

    // 表单中第一个控件元素
    // field1 = form.elements[0]
    // 表单中名为textbox1的控件元素s
    // field2 = form.elements["textbox1"]

    // pattern input约束字段
    // checkValidity 表单或表单元素检测有效性：可以自己写一个

    // contenteditable: 给任意元素设置该属性 可变为可编辑元素 



    // 树型结构最大深度
    // let max = 0
    // const fn = (data, i = 0) => {
    //   i ++
    //   data.forEach(item => {
    //     const { children } = item
    //     if (children && children.length > 0) {
    //       if (i > max) {
    //         max = i
    //       }
    //       fn(children, i)
    //     }
    //   })
    // }
    // fn(o)
    // log(max)
    // 树型结构数据总数item
    // const fn = (data) => {
    //   let max = 0
    //   data.forEach(item => {
    //     max ++
    //     const { children } = item
    //     if (children && children.length > 0) {
    //       max += fn(children)
    //     }
    //   })
    //   return max
    // }
    // log(fn(o))


    // defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的
    // import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载
    // CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
    // CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。


    // tree selected
    // function fn(data) {
    //   data.forEach(item => {
    //     const { children } = item
    //     if (children && children.length > 0) {
    //       fn(children)
    //       item.selected = children.every(({ selected }) => selected === true)
    //     }
    //   })
    // }
    // fn(arr)


    // 数组扁平化

    // const flatten = arr => {
    //   arr.reduce((prev, item) => (
    //     prev.concat(Array.isArray(item) ? flatten(item) : item)
    //   ), [])
    // }

    // Array.protype.flat()用于将数组“拉平”，变成一维数组，返回一个新数组。
    // flat()默认只会拉平一层，flat（n）拉平n层，Infinity无限次
    // flat()会跳过空格

    // function flatten(arr){
    //   while(arr.some(item=>Array.isArray(item))) {
    //       arr = [].concat(...arr);
    //   }
    //   return arr;
    // }

    // 创建指定长度的数组
    // [...new Array(5).keys()]
    // Array.from({ length: 5 })
    //  伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）
    //  可迭代对象（可以获取对象中的元素,如 Map和 Set 等）


    // this传递
    // function fn(f) {
    //   f()
    // }
    // function Fn() {
    //   this.f = function() {
    //     log(this)
    //   }
    //   this.f2 = () => {
    //     log(this)
    //   }
    // }

    // fn(new Fn().f)  // window
    // fn(new Fn().f2) // Fn{}

    // createVNode
    // const o = [
    //   {
    //     value: 1,
    //     children: [
    //       {
    //         value: 11,
    //         children: [
    //           {value: 111}
    //         ]
    //       },
    //       {
    //         value: 12,
    //         children: [
    //           {
    //             value: 121,
    //             children: [
    //               {
    //                 value: 1211,
    //               },
    //               {
    //                 value: 1212,
    //               }
    //             ]
    //           }
    //         ]
    //       }
    //     ]
    //   },
    //   {
    //     value: 2,
    //     children: [
    //       {
    //         value: 21,
    //         children: [
    //           {value: 211}
    //         ]
    //       },
    //       {
    //         value: 22,
    //         children: [
    //           {value: 221}
    //         ]
    //       }
    //     ]
    //   },
    // ]

    // function createVNode(data) {
    //   return data.map(({ value, children }) => (
    //     <div key={value}>
    //       {value}
    //       {children && (
    //         createVNode(children)
    //       )}
    //     </div>
    //   ))
    // }




    // ReactDOM.render 实现
    // function render(vNode, container) {
    //   if (typeof vNode === 'string') return container.appendChild(document.createTextNode(vNode))
    //   const { type, props } = vNode
    //   const el = document.createElement(type)
    //   for (let key in props) {
    //     if (key === 'children') {
    //       if (props[key] instanceof Array) {
    //         props[key].forEach(item => {
    //           render(item, el)
    //         })
    //       } else {
    //         render(props[key], el)
    //       }
    //     } else {
    //       el.setAttribute(key, props[key])
    //     }
    //   }
    //   container.appendChild(el)
    // }


    // 自定义事件
    // const box = document.getElementById('box')
    // box.addEventListener('testEvent', (e) => {
    //   console.log(e)
    // }, false)

    // const event = document.createEvent('HTMLEvents')
    // event.initEvent('testEvent', false, false)// 事件是否冒泡; 是否可以用 preventDefault() 方法取消事件

    // box.dispatchEvent(event)


    // [1, 4, -5, 10].find((n) => n < 0, obj) // -5 findIndex 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象
    // function f(v){
    //   return v > this.age;
    // }
    // let person = {name: 'John', age: 20};
    // [10, 12, 26, 15].find(f, person); 

    // Array.of(1, 2) // [1, 2]

    // 截数组
    // const arr = [1,2,3,4,5,6,7]
    // 1. const [first, ...rest] = arr
    // 2. arr.slice(1, arr.length)

    // 父窗口通过window.open获取子窗口；子窗口通过window.opener window.parent获取父窗口

    // 嵌套解构赋值
    // const { a: { b: { c: x = 'default' }, a, b } } = {a: {b: {c: 1}}}  // 解构赋值别名使用默认值
    // log(a, b)  // error ,a ,b
    // log(x)  // 1
    // function move({x = 0, y = 0} = {}) {  // 函数解构赋值也使用默认值
    //   return [x, y]
    // }
    // log(move())  // 不会报错

    // 交换变量的值
    // let x = 1;
    // let y = 2;
    // [x, y] = [y, x];

    // 递归几种情况 || 递归尾调用
    // const o = [
    //   {
    //     value: 1,
    //     children: [
    //       {
    //         value: 11
    //       }
    //     ]
    //   },
    //   {
    //     value: 2,
    //     children: [
    //       {
    //         value: 21,
    //         children: [
    //           {
    //             value: 211
    //           },
    //           {
    //             value: 212
    //           },
    //         ]
    //       },
    //       {
    //         value: 22,
    //         children: [
    //           {
    //             value: 221,
    //             children: [
    //               {
    //                 value: 2211
    //               }
    //             ]
    //           },
    //         ]
    //       },
    //     ]
    //   },
    //   {
    //     value: 3
    //   }
    // ]
    // function fn(data) {
    //   let arr = []
    //   for(let i = 0, item; item = data[i ++];) {
    //     const { value, children } = item
    //     arr.push(value)
    //     if (children && children.length > 0) {
    //       arr = arr.concat(fn(children))
    //     }
    //   }
    //   return arr
    // }
    // let arr = []
    // function fn(data) {
    //   for(let i = 0, item; item = data[i ++];) {
    //     const { value, children } = item
    //     arr.push(value)
    //     if (children && children.length > 0) {
    //       fn(children)
    //     }
    //   }
    // }
    // function fn(i, data, arr) {
    //   const node = data[i]
    //   if (node) {
    //     for (let j = 0, item; item = node[j ++];) {
    //       const { value, children } = item
    //       arr.push(value)
    //       if (children && children.length > 0) {
    //         data.push(children)
    //       }
    //     }
    //     i ++
    //     return fn(i, data, arr)
    //   } else {
    //     return { i, data, arr }
    //   }
    // }
    // console.log(fn(0, [o], []).arr)

    // const arr = [
    //   'http://img5.imgtn.bdimg.com/it/u=2807537560,355918843&fm=26&gp=0.jpg',
    //   'http://img0.imgtn.bdimg.com/it/u=2324424292,2939395458&fm=26&gp=0.jpg',
    //   'http://img5.imgtn.bdimg.com/it/u=118995679,1126901632&fm=26&gp=0.jpg'
    // ]
    // const box = document.getElementById('box')
    // !function fn(i) {
    //   if (i >= arr.length) return
    //   const img = document.createElement('img')  // new Image()
    //   img.src = arr[i]
    //   img.style.width = '100px'
    //   img.style.height = '100px'
    //   img.onload = function() {
    //     console.log(i)
    //     box.appendChild(img)
    //     fn(i + 1)
    //   }
    //   console.log('sc')
    // }(0)

    // function Func() {
    //   this.name = 'name'
    //   this.sayName = function() {
    //     console.log(this.name)
    //   }
    // }

    // Func.prototype = {
    //   // constructor: Func,
    //   b: 'b',
    //   sayThis: function() {
    //     console.log(this)
    //   }
    // }

    // Object.defineProperties(Func.prototype, {
    //   constructor: {
    //     constructor: false,
    //     value: Func
    //   }
    // })

    // const o = New(Func)

    // // o.sayThis()

    // for (let key in o) {
    //   log(key)
    // }

    // log(o)


    // function New(fn) {
    //   const obj = {}
    //   fn.call(obj)
    //   obj.__proto__ = fn.prototype
    //   return obj
    // }



    // const arr = [2,2,2,2,1,1,1,2,2,4,4]
    // const newArr = []
    // const obj = {}
    // for (let i of arr) {
    //   obj[i] = true
    // }
    // console.log(Object.keys(obj))

    // for (let i of arr) {
    //   if (newArr.indexOf(i) == -1) {
    //     newArr.push(i)
    //   }
    // }
    // console.log(newArr)


    // splice: 删除 插入 替换 截取

    // const arr = [{a: 1,b: {b2: 2}},[2,3,[4,5]],'c']
    // function deepCopy(obj) {
    //   let newObj = obj.constructor === Object ? {} : []
    //   for (var key in obj) {
    //     if (typeof obj[key] === 'object') {
    //       newObj[key] = arguments.callee(obj[key])
    //     } else {
    //       newObj[key] = obj[key]
    //     }
    //   }
    //   return newObj
    // }

    // const newArr = deepCopy(arr)

    // arr[0].a = 2
    // arr[0].b.b2 = 1

    // console.log(arr)
    // console.log(newArr)

    // const obj = new Object(function(){})  // 传什么类型的值就生成什么类型的对象实例
    // console.log(obj instanceof Function)

    // 基本包装类型
    // 为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型:Boolean、Number 和 String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。来看下面的例子。
    //     var s1 = "some text";
    //     var s2 = s1.substring(2);
    // 这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的 substring()方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上 讲它们不应该有方法(尽管如我们所愿，它们确实有方法)。其实，为了让我们实现这种直观的操作， 后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要 从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。
    // (1) 创建 String 类型的一个实例;
    // (2) 在实例上调用指定的方法;
    // (3) 销毁这个实例。

    // localeCompare()  
    // var stringValue = "yellow";
    // alert(stringValue.localeCompare("brick")); //1
    // alert(stringValue.localeCompare("yellow")); //0
    // alert(stringValue.localeCompare("zoo")); //-1

    // alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello"

    // var uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";
    // decodeURI() decodeURIComponent()
    // //http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start
    // alert(decodeURI(uri));
    // //http://www.wrox.com/illegal value.htm#starttabulator
    // alert(decodeURIComponent(uri))

    // Math.max() min() 技巧  values.constuctor === Array.prototype
    // var max = Math.max.apply(Math, values);

    // input 只允许输入？？？
    // <input onkeyup="value=value.replace(/[^0-9]/g,'')" onpaste="value=value.replace(/[^0-9]/g,'')" oncontextmenu = "value=value.replace(/[^0-9]/g,'')">


    // let totalS = 62 

    // function countDown() {
    //   if (totalS >= 0) {
    //     m = transition(Math.floor(totalS / 60))
    //     s = transition(totalS % 60)
    //     timeStr = '' + m[0] + m[1] + '分' + s[0] + s[1] + '秒'
    //     document.body.innerHTML = timeStr
    //     --totalS
    //   } else {
    //     clearInterval(timer)
    //   }
    // }

    // timer = setInterval('countDown()', 1000)

    // function transition(str) {
    //   return str < 10 ? '0' + str : str + ''
    // }

    // callee
    // function fn() {
    //   log(arguments.callee)
    // }

    // Object.create()  //用对象去（带原型带属性）创建新对象
    //使用指定的原型对象及其属性去新建一个新的对象

    // Object.keys && Object.values
    // Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键值对数组

    // 􏲒􏱁 resizeTo()􏱰 resizeBy()􏱜􏱝􏰜􏱧􏱍􏷽􏲈􏲉􏲊􏽿􏴔􏰔􏳵􏵚􏱜􏱝􏰜􏱧􏱍􏷽􏲈􏲉􏲊􏽿􏴔􏰔􏳵􏵚 调整浏览器窗口大小

    
    // 当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境
    // js运行时进入全局环境，生成全局执行上下文
    // 进入函数，生成函数执行上下文(调用帧)
    // 通过栈的存取方式来管理执行上下文（执行栈 | 调用栈 | call stack）
    // 栈遵循"后进先出(Last in First Out)"的规则

    // 作用域：限制代码范围内变量的可用性
    // 作用域链作用：本质上是一个指向变量对象的指针列表 只引用但不实际包含变量对象(保证执行环境内变量的合法、有序访问;作用域的前端，始终都是当前执行环境的变量对象(如果是函数执行环境 AO则充当其变量对象))
    // 函数的对象上下文 => this

    // 当调用一个函数：将该函数压入执行栈并创建执行环境(变量初始化及提升)

    // 执行环境：每次进入函数都会创建一个完全不同的执行环境; 运行完毕即销毁
    // 执行环境组成: 变量对象VariableObject（形参 变量 函数声明）/ ActivationObject: （arguments 形参 变量 函数声明）; 
    //             作用域链([[Scopes]]：由当前和父级变量对象生成);
    //             this;设置 this 值

    // 然后执行代码
    

    // 闭包：父函数被销毁时 子函数仍可以访问父函数所声明的变量和作用域链。多个子函数的的[[scopes]]都是同时指向父级作用域链的 是完全共享的
    // ：内部函数的作用域链仍然保持着对父函数活动对象的引用

    // 前端资源优化
    // 1. 文件压缩
    // 2. 文件合并 减少http 请求
    // 3. cdn静态资源托管
    // 4. 懒加载（路由 图片）
    // 5. 节流 防抖

    // 伪数组：
    // 1. 按索引的方式存储数据
    // 2. 具有length属性
    // 3. 原生部署iterator遍历器接口
    // 4. 不继承Array.prototype 也就不具有Array的方法
    // => Array
    // 1. Array.prototype.slice.call(a)
    // 2. [...a]
    // 3. Array.from(a)
    
    
    // 1. cookie会在http请求中携带 
    // 2. 存储空间：cookie存储大小为4k / webStorage为5M
    // 3. 有效期：cookie手动设置有效期 / localStorage永久存储 sessionStorage会话关闭
    // 4. 作用域不同 cookie有path概念 仅存储在某路径下 / webStorage不会



    // react知识
    // 重复代码逻辑：就要考虑复用 1. 高阶函数 2. HOC 3. renderProps 

    // 为什么不在componentWillMount中请求n数据？
    // 如果使用服务端渲染，componentWillMount会执行多次；
    // componentDidMount中DOM元素已经初始化完毕，可以对DOM元素进行操作 而且setState会发生重渲染 不会阻碍初始化

    // react 的优点？
    //   首先 react的声明式(直接声明DOM元素和属性)让代码更直观 写法更灵活
    //   组件化开发 组件可复用 可维护性高 符合开发人员模块化开发的思想
    //   用虚拟DOM 和 diff算法来操作DOM 提高了性能
    //   以facebook为背景 有着很成熟的生态圈和发展潜力
    //   个人喜欢react的原因：写法灵活 相较于vue也可说复杂 比较能锻炼思维 代码优雅
    //   使用框架的好处：用框架规则来规范代码 使应用工程化，提高可维护性，组件化，用state来控制交互逻辑 更简单
    // 虚拟DOM
    // 虚拟DOM和diff算法？
    //   虚拟DOM是真实DOM的抽象层 他是一个轻量级的js对象 所拥有的属性极少 而真实DOM中创建一个节点需要继承上百条属性 react在初始化的时候就会建立一个虚拟DOM树 render方法的返回值就是虚拟DOM
    //   当状态发生改变的时候 react会收集之前所有的操作进行一个合并 然后生成一个新的虚拟DOM树 跟旧树进行对比 通过diff算法找出最小改变 更新到真实DOM当中进行一次统一的重绘 以减少没必要的DOM读写
    //   而标准DOM每进行一次DOM操作就会重绘一次DOM树
    //   虚拟DOM的缺点：在应用初始化首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会慢一些
    // diff算法
    //   diff算法：是DOM树之间层对层比较 大大减少了需要遍历子节点的复杂度 因为在web应用中很少把一个组件节点移动到这颗树的其他层次(结构稳定) 它们通常只是在孩子节点的同层之间移动
    //     比如说在对比过程中发现两个节点的类型不一样 那么直接删除这个节点和它的子节点并重新创建添加 即创建以这个节点为根的子树，如果相同 就进行下一步更深的比较虚拟DOM
    // key
    //     兄弟组件之间需要标识唯一不同的key来让react记住这些元素 来简化更新的过程：因为在做diff的时候 如果元素有key react会去旧树中的同层中寻找存在该key的元素并进行对比 相同则复用不同则更新，没有的话就跟相同位置的元素进行比较。会大大提高更新过程的效率
    //     为什么key值最好不要用数组索引下标？如果用数组索引值来定义key的话 当数组新增或删除元素 这个元素之后所有元素的key值就会发生改变但这些元素本身并没有发生改变只是移动了位置 从而导致了没必要的更新
    // 如果兄弟组件内的元素不会发生改变可以使用数组索引
    // react优化
    // react 优化途径？
    //   尽量将事件函数定义在构造器内声明为实例：少在render内使用bind函数和新建函数 因为每一次render都会生成一个新函数；其他引用数据类型亦是如此 因为react判断是否需要重渲是进行的浅层比较
    //   使用shouldcomponentupdate或PureComponent或Memo来进行对比阻止无必要渲染
    //   render函数内尽量不要做副作用或复杂计算
    //   元素或组件key值尽量使用唯一且不变的
    //   不要随意更改外层包裹组件的节点类型 因为diff算法 两个节点类型不同将废掉此节点和其子节点重新创建
    //   如果使用Redux 可以使用Redux中间件reselect来把store的state来进行缓存重用
    //   懒加载组件 import方法动态 配合React Lazy Suspense
    //   使用Fragment减少额外标签的创建

    // redux运行流程
    // redux 运行流程？
    //   首先view视图层发出action 通过dispatch将动作传递到store
    //   store调用reducer 通过接受的state和action来重新计算state并返回一个新state给store的state
    //   state发生改变 执行所有通过subscribe订阅的函数来完成视图的重渲
    // Js代码优化
    // js 代码性能优化
    //   script标签使用defer属性：跟文档同时加载 在文档加载完后执行 anync 跟文档同时加载 加载完立刻执行
    //   尽量减或批量化DOM操作
    //   对重复访问的dom对象使用局部变量保存 否则每次访问都要去DOM操作 而且每次使用完毕进行销毁
    //   元素加事件尽量使用时间委托 因为遍历DOM元素会影响性能
    //   尽量避免全局变量的搜索 声明局部变量 避免作用域链的查找
    //   switch比if else要快 for in是最浪费性能的一种循环 每次都要通过原型链搜索属性
    //   遍历数组，应先缓存数组长度
    //   处理数据时的尾调用递归优化
    //   其他的还要落实在具体的代码中
    // 单向数据流
    // 单向数据流？
    //   单向数据流是指只能从一个方向一个源头来修改状态 它限制了修改状态的方式 让状态变的可追踪 易调试 出了问题	可以更快速的找到问题所在 所以比如父给子传值 这个值在子组件内不得修改 修改了就不符合单向数据流会让应用内数据的流向变得繁琐 会导致一系列问题
    // setState
    // setState的理解？
    //   当调用setState，react会收集一批需要更新的组件，每一个组件又对应一批需要更新的状态，然后一次性批量更新来保证渲染的性能，是通过一个队列机制来实现的异步更新
    //       当执行setState的时候会收集需要更新的state 合并后放入更新队列而不会立即更新 到了一定时间它会批量处理这些更新 执行更新周期重绘页面
    //       setState在rend函数执行的时候才会被更新或者shoulComponentUpdate返回false之后
    // setState同步
    // setState怎么实现同步更新？
    //   setState也可以同步更新 由react引发的事件处理而调用的setState是异步更新 而绕过react通过addEventListener()添加绑定事件函数和setInterval setTimeout所调用的setState是同步更新 还可以利用函数式setState中的state来获取到正在队列中的最新state 或是通过setState第二个回调函数参数来拿到更新之后的state
    // setState更新原理
    // setState更新机制原理？
    //   setState是通过一个更新机制 batch update 来实现的 在MVC或者是MVVM框架中可以理解为将一段时间内对model的修改批量更新至view的过程
    //   每次setState会将新state放入队列当中 然后根据一个变量来判断是否直接更新state 这个变量默认为false 也就是直接同步更新state 但是当通过react事件或生命周期调用的setState react会调用一个函数来修改这个变量为ture 从而放入等待队列中一步批量更新
    //   当react的生命周期被调用或者react合成事件被触发时，会将变量isBatchingUpdates设置为true，表示开启了一个事务；
    //   当setState时，先将待更新的state放入更新队列([] _pendingStateQueue)；
    //   然后判断isBatchingUpdates为true：则将调用setState的组件实例也放入一个队列([] dirtyComponents)，等待批量更新；否则为false则直接进入该组件的更新流程
    //   当组件更新完毕并且调用callback完成后会将isBatchingUpdates重置为false，表示当前事务已完成。
      

    // react初始化渲染原理
    // react-babel 会将标签编译成React.createElement(), 返回一个DOM描述对象（虚拟DOM）
    // {
    // $$typeof: Symbol(react.element),	key: null,	props: {a: "a", children: "1"},	ref: null,	type: "div",	_owner: null,	_store: {validated: false}, _self: null,	_source: null,	__proto__: Object
    // }

    // 判断Element类型：1.DOM描述对象或数组 2.基础数据类型
    // 1. 步骤：首先判断type，1.1 原生DOM字符串 1.2 组件函数：
    //       1.1 直接调用ReactDOMComponent.mountComponent：生成真实DOM元素，再将children插入为子元素判断类型重复以上
    //       1.2 调用ReactCompositeComponentWrapper.mountComponent：react会生成组件实例 FuncComponent：Func(props)；ClassComponent：new Func(props).render()，调用生命周期，返回Element判断类型重复以上
    //   2. 是基础类型再判断是不是空类型 2.1 string | number 2.2. undefined null false true
    //       2.1 ReactDOMTextComponent
    //       2.2 ReactDOMEmptyComponent
    // 调用这些方法生成真实DOM对象并插入到对应container
    //  



    // MVC和MVVM
    // MVC和MVVM？
    //   都是软件架构方式
    //   MVC：View传送指令到Controller；Controller完成业务逻辑后更改Medol；Medel将数据发送至View 实现视图的更新 数据流向是单向的  缺点 View和Model紧密联系 耦合度太高
    //   MVVM：将数据双向绑定做为核心 VM充当视图和数据源的观察者 View和Model之间没有联系 View的改变会传送至VM VM完成业务逻辑更新Model；反之亦然
    //   View的变化会修改数据源Model；Model的变化也会反映在视图上 优点 低耦合度 View和Model不能直接交互 当View改变Model可以不用发生改变 反之亦然；提高重用性；可测试性高

    // 数据双向绑定原理？
    //   通过 数据劫持 结合 发布订阅者模式 实现的
    // CMD和AMD
    // CMD和AMD？
    //   都是模块化开发规范
    //       commonJS:  服务端的模块化规范 nodeJS采用了这个规范
    //   AMD：推崇依赖前置（依赖提前执行）；需要用到对应的库 RequireJS；它主要解决两个问题：JS文件的依赖关系 JS依赖文件加载时会阻塞页面渲染；而且不会污染全局环境
    //         requireJS加载的函数是异步加载的 这样浏览器不会失去响应；只有模块加载完毕才会执行回调 解决了文件依赖问题
    //   主要通过difine方法将代码定义为模块 require方法将模块引入加载
    //   require方法接受两个参数第一个参数为数组 表示所依赖模块 第二个参数是模块记载完成执行的回调函数
    //   CMD：推崇依赖就近（用到才加载）；
    //   最大的区别：对依赖模块的执行时机不同
    // react router原理
    // react router 的原理？
    // 通过H5的history API来实现的无刷新页面修改地址栏
    // history.pushState(state,’标题’,url)
    // replaceState 方法 
    // onpopstate事件
    // pushState和replaceState方法用来改变history实体 当被改变的时候会触发onpopstate事件
    // 什么情况redux
    // 什么情况下使用Redux？
    //   redux就是一个状态管理器 用来共享状态 免去组件间的传值 所以：
    //   组件内某些状态需要共享
    //   页面内交互逻辑复杂 一个状态需要改变全局多个组件逻辑
    //   与服务器大量交互且多数据源
    //   如果需求达不到则不需使用redux
    // redux缺点
    // Reduxde 缺点？
    // 需求达不到不需要使用 无疑增加了代码量
    // 更改一处状态需要调用多个文件来协同处理 actionCreator啦reducer啦connect啦
    // 需要发送异步action还需要通过中间件来处理 它整体的逻辑是不简单的
    // reducer纯函数
    // reducer纯函数？
    // 1.它的返回结果只依赖于他的参数 不依赖外部
    // 同样的输入必定的发哦同样的输出
    // 所以返回值不接受不纯的方法 比如random随机
    // 2.在执行过程中不对外具有副作用
    // 容器组件
    // 容器组件和UI组件？
    // UI组件只负责展示 不具有业务逻辑
    // 没有状态 数据只依赖于props
    // react和vue的区别
    // react和vue的区别？
    //     virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整颗组件树.而对于React而言,每当应用的状态被改变时,这颗DOM树和它的子树都会重新渲染,需要shouldComponentUpdate这个钩子来控制
    //     Vue封装了大量的API，react主要构建UI 内置API很少 很多功能需要自己来写逻辑 或者引用第三方
    //     vue书写html结构更趋向于原生写法 而react是声明式的 将html结构嵌入js代码 写法更自由更灵活

    // redux 三大原则
    // 单一数据源：只存在一个state 只存在一个store
    // state：只能通过显示的dispatch一个action来更改state
    // resucer是一个纯函数：只能通过纯函数来修改state






    // 其他知识
    // fetch && xhr && axios
    // fetch：ES6新规范；免封装 语法简洁语义化；基于promise设计 解决回调地狱问题；可以设置不透传cookie
    // 缺点：不能中断请求，没有获取当前请求状态的方法


    // 像素
    // 物理像素和逻辑像素？
    // 物理像素=设备独立像素 逻辑像素=CSS像素
    // dpr 等于 物理像素比逻辑像素 window.devercePR
    // iphone6  375*667
    // Onload 
    // onload事件？
    // 对象: window image
    // 标签: body img script iframe
    // post  get
    // ajax post和get的区别？
    // （1）使用Get请求时,参数在URL中显示,而使用Post请求,则不会显示出来； 
    // （2）Post传输的数据量大，可以达到2M，而Get方法由于受到URL长度的限制,只能传递大约1024字节. 
    // （3）Get请求请求需注意缓存问题,Post请求不需担心这个问题； 
    // （4）Post请求必须设置Content-Type值为application/x-form-www-urlencoded； 
    // （5）发送请求时,因为Get请求的参数都在url里,所以send函数发送的参数为null,而Post请求在使用send方法时,却需赋予其参数； 
    // （6）GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。
    // 对象遍历：Object.keys for in Object.getOwnPropertyNames
    // Object.keys: 遍历对象的自有的 可枚举属性
    // For in: 遍历对象的自有和原型的 可枚举属性
    // Object.getOwnPropertyNames: 遍历对象的自有的 可枚举不可枚举属性
    // 继承
    // 继承？
    // 1.原型继承(拷贝继承,原型链继承)：将父类的实例赋给子类构造器的prototype,将父类的原型通过遍历的方式赋给子类构造器原型
    // 2.构造继承：将父类构造函数的作用域指向子类F.apply(s,arguments)
    // 3.实例继承：子类内部返回父类实例
    // 4.组合继承：结合构造继承与原型继承
    // 5.寄生组合继承：结合构造继承，通过寄生的方式砍掉父类的实例方法，
    // 创建一个空类，把父类的原型赋给空类的原型，再把这个实例赋给子类构造器的原型
    // ES6类继承：
    // 面向对象
    // 面向对象式编程：重用性、灵活性和扩展性 把程序模块化 这些模块可以在类的外部被调用，符合编程思维的高内聚低耦合（继承，封装，多态）
    // Ajsx
    // ajax步骤？
    // 创建XHR对象
    // 调用open方法创建请求
    // 调用send方法发送请求
    // onreadystatechange获取请求的状态码
    // 判断状态码是否成功
    // 调用ajax的responseText属性返回数据
    

    // CSS伪元素清除浮动？
    // ::after {content: “”, display:block, clear:both, height: 0, visibility: hidden}
    
    // 箭头函数和普通函数的区别？
    // 不绑定this(this指向为上下文的作用域)
    // 不绑定arguments
    // 没有原型属性
    // 不能构造实例(不能使用new操作符)

    // Let和const
    // let和const？
    // Var声明的变量会挂载在window上, let const则不会
    // 有自己独立的块级作用域
    // 不存在变量提升 必须先声明后使用
    // 相同作用域内不可以重复声明 不可以同时声明多个变量
    // 暂时性死区
    // Const 不允许被重新赋值 声明时必须立刻赋值
    

    // window 提供js与浏览器交互的方法与接口
    // Window(BOM浏览器对象模型)：window.open
    // Navigator 访问者的浏览器信息 userAgent
    // History：浏览器历史信息 包括前进forward后退goback一些方法
    // Location：当前url地址和一些跳转的方法
    // Screen: 用户显示器的分辨率详细信息

    // 内存泄漏
    // 内存泄漏的原因？
    // 意外的全局变量设置
    // 定时器没有被清除
    // 一些循环的回调
    // 闭包生成的变量

    // 闭包
    // 闭包的特点？
    // 函数总能访问其外部函数所声明的变量
    // 这些变量不会被垃圾回收机制回收
    // 容易引起内存泄漏
    // 垃圾回收机制
    // JS的垃圾回收机制会按固定的时间周期性的执行
    // 最常见的方式是 1. 标记清除

    // 2. 引用计数



    // JS预解析
    // js预解析？
    // Js引擎
    // 单线程和事件循环
    // 单线程和事件循环？
    // Js是单线程的脚本：代码按顺序执行 前面任务处理好才会执行后边的 他会阻塞程序的运行
    // 但是js当中又有很多异步操作 所以它又有一个事件循环的机制：
    // 程序在执行时 当遇到异步函数 js会将它在浏览器的事件表中进行记录 然后继续向下执行 当这个异步时间结束之后 事件表会将它的回调函数添加至事件队列等待执行 当执行栈的程序执行完毕 js会轮询事件队列 将它发现的函数置入执行栈执行；执行栈为空时 则继续轮训事件列表

    // 事件队列又分为宏任务队列和微任务队列：
    // 宏任务：定时器
    // 微任务：new Promise；new MutaionObserver
    // 轮询事件列表有优先级 首先会查找微任务队列 有任务就将排在第一位的回调执行 没有再查找宏任务队列（每次事件轮训只会拿出一个任务, 因为微任务优先级高, 所以也可以理解为每次循环清空微任务列表, 没有微任务的话就去拿一个宏任务） 如此循环

    // 调用栈：解析器去处理程序的机制，是一种栈数据结构：能够追踪子任务的运行状态


    // 二叉树？
    // 是指数据结构中每个节点最大有两颗子树

    // 复杂度？
    // 时间复杂度：执行算法所需要的计算工作量(时间)
    // 空间复杂度：执行算法所需要的内存空间(内存占用)

    // CSS选择器？
    // 通配符选择器
    // 元素选择器
    // 类选择器 单类和多类
    // ID选择器
    // 属性选择器 具体属性 部分属性
    // 派生选择器 后代选择器 子选择器 相邻兄弟 关联选择器
    // 群组选择器
    // 伪类选择器 hover nth-of-type nth-child
    // 伪元素选择器

    // script元素
    // Async：立即下载脚本 异步下载 不妨碍文档的加载（跟文档同时加载）加载完成后立即执行且不保证执行顺序 只对外部引入代码有效
    // Defer：立即下载脚本 异步下载 不妨碍文档的加载（跟文档同时加载）等待所有文档加载完毕后执行  只对外部引入代码有效
    // Script放入</body>前的好处：解析文档按顺序线性加载 放在body末尾说明文档全部加载完毕再加载js代码（不妨碍文档的加载）
    // 返回为false的值
    // 0
    // “”
    // Null
    // Undefined
    // NaN
    // false
    // 强制类型转换
    // Number() Bloean() parseInt() parseFloat() toString() String()


    // 工作当中最难解决的问题
    // 自己的技术栈

    // 平时学习途径？
    // 后期:
    // 慕课网 网易云课堂 腾讯课堂 
    // github 知乎 csdn 掘金 简书


    // flex：
    // // 父元素
    // flex-direction: row(默认) | row-reverse | column | column-reverse // 主轴排列方式（行 | 列）
    // flex-wrap: nowrap | wrap | wrap-reverse;  // 主轴放不下 换行 | 不换行
    // justify-content: flex-start | flex-end | center | space-between | space-around // 主轴方向对齐方式
    // align-items: flex-start | flex-end | center | baseline | stretch // 侧轴方向对齐方式
    // align-content
    // flex-flow: flex-direction || flex-wrap
    // // 子元素
    // order: number // 项目的排列顺序。数值越小，排列越靠前，默认为0
    // flex-grow: number // 项目所占剩余空间比例 默认为0，即如果存在剩余空间，也不放大
    // flex-shrink // 项目缩小比例，默认为1，即如果空间不足，该项目将缩小
    // flex-basis
    // align-self: // 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch
    // flex: flex-grow || flex-shrink || flex-basis


    



    
  </script>
</body>

</html>